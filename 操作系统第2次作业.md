# 操作系统第2次作业

201908010224黄雅妮

## 第26章

#### 26.1

**开始，我们来看一个简单的程序，“loop.s”。首先，阅读这个程序，看看你是否能理解它：cat loop.s。然后，用这些参数运行它：**
**./x86.py -p loop.s -t 1 -i 100 -R dx**
**这指定了一个单线程，每 100 条指令产生一个中断，并且追踪寄存器%dx。你能弄清楚%dx  在运行过程中的价值吗？你有答案之后，运行上面的代码并使用-c  标志来检查你的答案。注意答案的左边显示了右侧指令运行后寄存器的值（或内存的值）。**

loop.S试图修改寄存器%dx的值，将寄存器%dx的值减一后，再测试其是否为0，如果大于等于0则跳转至top处。从运行结果来看，线程在第一轮减1操作后便终止了程序，所以可以推断出%dx的原值为0；

？0

？-1

？ -1 

？ -1

？ -1

![image-20211112101945421](https://gitee.com/nnilk/cloudimage/raw/master/img/202111121019512.png)

加上-c标志，验证正确

![image-20211112103721614](https://gitee.com/nnilk/cloudimage/raw/master/img/202111121037711.png)

#### 26.2

**现在运行相同的代码，但使用这些标志：**

**./x86.py -p loop.s -t 2 -i 100 -a dx=3,dx=3 -R dx**
**这指定了两个线程，并将每个%dx 寄存器初始化为 3。%dx 会看到什么值？使用-c 标志验证你的答案。多个线程的存在是否会影响计算？这段代码有竞态条件吗？**

可以看到看到线程T0进行4轮减1操作后，%dx的值为-1，然后终止了程序。此时发生中断，恢复上下文，线程T1再次进 行4轮减1操作后终止程序。所以最终结果并没有受到影响。

![image-20211112104310522](https://gitee.com/nnilk/cloudimage/raw/master/img/202111121043689.png)

加上-c标志，可以看到中断时间大于线程执行时间，不存在竞态条件

![image-20211112110037895](https://gitee.com/nnilk/cloudimage/raw/master/img/202111121100246.png)

#### 26.3

**现在运行以下命令：**
**./x86.py -p loop.s -t 2 -i 3 -r -a dx=3,dx=3 -R dx**
**这使得中断间隔非常小且随机。使用不同的种子和-s 来查看不同的交替。中断频率是否会改变这个程序的行为？**

可以看到，两个线程之间频繁地发生中断。但是两个线程的行为未改变，都是进行了4轮减1操作后终止。所以中断频率并不会改变程序的行为。

![image-20211112110339370](https://gitee.com/nnilk/cloudimage/raw/master/img/202111121103638.png)

加上-c标志， 可以看到，计算结果的确未收到影响，因为线程0和线程1修改的不是共享变量

![image-20211112111454021](https://gitee.com/nnilk/cloudimage/raw/master/img/202111121114756.png)

#### 26.4

**接下来我们将研究一个不同的程序（looping-race-nolock.s）。**
**该程序访问位于内存地址 2000 的共享变量。简单起见，我们称这个变量为 x。使用单线程运行它，并确保你了解它的功能，如下所示：**
**./x86.py -p looping-race-nolock.s -t 1 -M 2000**

**在整个运行过程中，x（即内存地址为2000）的值是多少？使用-c 来检查你的答案。**

looping-race-nolock.s将X加1后回存到内存2000，然后再将bx寄存器的值减一后，再检测bx%是否大于0，如果大于0则再次循环，否则终止程序。

因为不知道内存地址2000初始值，无法推断出x的值。

```
.main
.top	
mov 2000, %ax  # get 'value' at address 2000
add $1, %ax    # increment it
mov %ax, 2000  # store it back
sub  $1, %bx  
test $0, %bx
jgt .top	
halt
```

![image-20211112112224072](https://gitee.com/nnilk/cloudimage/raw/master/img/202111121122346.png)

加上-c标志，可以看到x的初始值为0，执行程序后，x的值变为1

![image-20211112114556739](https://gitee.com/nnilk/cloudimage/raw/master/img/202111121145016.png)



## 第28章

#### **28.1**

**首先用标志-p flag.s 运行x86.py。该代码通过一个内存标志“实现”锁。你能理解汇编代码试图做什么吗？**

flag.s汇编代码如下：

代码实现了一个简单的锁。flag变量指示锁是否被持有，临界区是将全局变量进行加一操作

```c
.var flag
.var count

.main
.top

.acquire
mov  flag, %ax      # 获取锁
test $0, %ax        #如果当前flag==0，则锁未被持有
jne  .acquire       # 重复获取，直至锁可用
mov  $1, flag       # 获取锁，将flag置1

# critical section
mov  count, %ax     #count+1 
add  $1, %ax        
mov  %ax, count      

# release lock
mov  $0, flag       # 释放锁

# see if we're still looping
sub  $1, %bx
test $0, %bx
jgt .top	

halt
```

运行结果如下：

可以看到，线程0先获取锁，执行完成后，count+1，又释放了锁。之后线程2再次获取了锁，将count再次加一后，释放锁。

```c
       Thread 0                Thread 1         

1000 mov  flag, %ax  
1001 test $0, %ax   
1002 jne  .acquire
1003 mov  $1, flag
1004 mov  count, %ax
1005 add  $1, %ax
1006 mov  %ax, count
1007 mov  $0, flag
1008 sub  $1, %bx
1009 test $0, %bx
1010 jgt .top
1011 halt
----- Halt;Switch -----  ----- Halt;Switch -----  
                         1000 mov  flag, %ax
                         1001 test $0, %ax
                         1002 jne  .acquire
                         1003 mov  $1, flag
                         1004 mov  count, %ax
                         1005 add  $1, %ax
                         1006 mov  %ax, count
                         1007 mov  $0, flag
                         1008 sub  $1, %bx
                         1009 test $0, %bx
                         1010 jgt .top
                         1011 halt

```

**28.2：使用默认值运行时，flag.s 是否按预期工作？它会产生正确的结果吗？使用-M 和-R 标志跟踪变量和寄存器（并打开-c 查看它们的值）。你能预测代码运行时标志最终会变成什么值吗？**

从题1的运行结果来看，flag的最终值为0，count的值为2. 使用标志 -M -R 验证，运行结果如下

```
flag count          Thread 0                Thread 1         

    0     0   
    0     0   1000 mov  flag, %ax
    0     0   1001 test $0, %ax
    0     0   1002 jne  .acquire
    1     0   1003 mov  $1, flag
    1     0   1004 mov  count, %ax
    1     0   1005 add  $1, %ax
    1     1   1006 mov  %ax, count
    0     1   1007 mov  $0, flag
    0     1   1008 sub  $1, %bx
    0     1   1009 test $0, %bx
    0     1   1010 jgt .top
    0     1   1011 halt
    0     1   ----- Halt;Switch -----  ----- Halt;Switch -----  
    0     1                            1000 mov  flag, %ax
    0     1                            1001 test $0, %ax
    0     1                            1002 jne  .acquire
    1     1                            1003 mov  $1, flag
    1     1                            1004 mov  count, %ax
    1     1                            1005 add  $1, %ax
    1     2                            1006 mov  %ax, count
    0     2                            1007 mov  $0, flag
    0     2                            1008 sub  $1, %bx
    0     2                            1009 test $0, %bx
    0     2                            1010 jgt .top
    0     2                            1011 halt

```

**28.3：使用-a 标志更改寄存器%bx 的值（例如，如果只运行两个线程，就用-a bx = 2，bx =2）。代码是做什么的？对这段代码问上面的问题，答案如何？**

将寄存器bx改为2之后，一个线程会两次进入临界区对全局变量count进行加1操作。从运行结果来看，线程0两次获取锁并修改count值，同样的，线程1也两次获取锁并修改了count值，最终flag的值为0，count等于4

```
       Thread 0                Thread 1         

1000 mov  flag, %ax
1001 test $0, %ax
1002 jne  .acquire
1003 mov  $1, flag
1004 mov  count, %ax
1005 add  $1, %ax
1006 mov  %ax, count
1007 mov  $0, flag
1008 sub  $1, %bx
1009 test $0, %bx
1010 jgt .top
1000 mov  flag, %ax
1001 test $0, %ax
1002 jne  .acquire
1003 mov  $1, flag
1004 mov  count, %ax
1005 add  $1, %ax
1006 mov  %ax, count
1007 mov  $0, flag
1008 sub  $1, %bx
1009 test $0, %bx
1010 jgt .top
1011 halt
----- Halt;Switch -----  ----- Halt;Switch -----  
                         1000 mov  flag, %ax
                         1001 test $0, %ax
                         1002 jne  .acquire
                         1003 mov  $1, flag
                         1004 mov  count, %ax
                         1005 add  $1, %ax
                         1006 mov  %ax, count
                         1007 mov  $0, flag
                         1008 sub  $1, %bx
                         1009 test $0, %bx
                         1010 jgt .top
                         1000 mov  flag, %ax
                         1001 test $0, %ax
                         1002 jne  .acquire
                         1003 mov  $1, flag
                         1004 mov  count, %ax
                         1005 add  $1, %ax
                         1006 mov  %ax, count
                         1007 mov  $0, flag
                         1008 sub  $1, %bx
                         1009 test $0, %bx
                         1010 jgt .top
                         1011 halt

```

**28.4：对每个线程将bx 设置为高值，然后使用-i 标志生成不同的中断频率。什么值导致产生不好的结果？什么值导致产生良好的结果？**

```
nnilk@nnilk-VirtualBox:~/文档/ostep-homework/threads-locks$ python2 ./x86.py -p flag.s -M flag,count  -c -a bx=2,bx=2  -i 2
ARG seed 0
ARG numthreads 2
ARG program flag.s
ARG interrupt frequency 2
ARG interrupt randomness False
ARG procsched 
ARG argv bx=2,bx=2
ARG load address 1000
ARG memsize 128
ARG memtrace flag,count
ARG regtrace 
ARG cctrace False
ARG printstats False
ARG verbose False


 flag count          Thread 0                Thread 1         

    0     0   
    0     0   1000 mov  flag, %ax
    0     0   1001 test $0, %ax
    0     0   ------ Interrupt ------  ------ Interrupt ------  
    0     0                            1000 mov  flag, %ax
    0     0                            1001 test $0, %ax
    0     0   ------ Interrupt ------  ------ Interrupt ------  
    0     0   1002 jne  .acquire
    1     0   1003 mov  $1, flag
    1     0   ------ Interrupt ------  ------ Interrupt ------  
    1     0                            1002 jne  .acquire
    1     0                            1003 mov  $1, flag
    1     0   ------ Interrupt ------  ------ Interrupt ------  
    1     0   1004 mov  count, %ax
    1     0   1005 add  $1, %ax
    1     0   ------ Interrupt ------  ------ Interrupt ------  
    1     0                            1004 mov  count, %ax
    1     0                            1005 add  $1, %ax
    1     0   ------ Interrupt ------  ------ Interrupt ------  
    1     1   1006 mov  %ax, count
    0     1   1007 mov  $0, flag
    0     1   ------ Interrupt ------  ------ Interrupt ------  
    0     1                            1006 mov  %ax, count
    0     1                            1007 mov  $0, flag
    0     1   ------ Interrupt ------  ------ Interrupt ------  
    0     1   1008 sub  $1, %bx
    0     1   1009 test $0, %bx
    0     1   ------ Interrupt ------  ------ Interrupt ------  
    0     1                            1008 sub  $1, %bx
    0     1                            1009 test $0, %bx
    0     1   ------ Interrupt ------  ------ Interrupt ------  
    0     1   1010 jgt .top
    0     1   1000 mov  flag, %ax
    0     1   ------ Interrupt ------  ------ Interrupt ------  
    0     1                            1010 jgt .top
    0     1                            1000 mov  flag, %ax
    0     1   ------ Interrupt ------  ------ Interrupt ------  
    0     1   1001 test $0, %ax
    0     1   1002 jne  .acquire
    0     1   ------ Interrupt ------  ------ Interrupt ------  
    0     1                            1001 test $0, %ax
    0     1                            1002 jne  .acquire
    0     1   ------ Interrupt ------  ------ Interrupt ------  
    1     1   1003 mov  $1, flag
    1     1   1004 mov  count, %ax
    1     1   ------ Interrupt ------  ------ Interrupt ------  
    1     1                            1003 mov  $1, flag
    1     1                            1004 mov  count, %ax
    1     1   ------ Interrupt ------  ------ Interrupt ------  
    1     1   1005 add  $1, %ax
    1     2   1006 mov  %ax, count
    1     2   ------ Interrupt ------  ------ Interrupt ------  
    1     2                            1005 add  $1, %ax
    1     2                            1006 mov  %ax, count
    1     2   ------ Interrupt ------  ------ Interrupt ------  
    0     2   1007 mov  $0, flag
    0     2   1008 sub  $1, %bx
    0     2   ------ Interrupt ------  ------ Interrupt ------  
    0     2                            1007 mov  $0, flag
    0     2                            1008 sub  $1, %bx
    0     2   ------ Interrupt ------  ------ Interrupt ------  
    0     2   1009 test $0, %bx
    0     2   1010 jgt .top
    0     2   ------ Interrupt ------  ------ Interrupt ------  
    0     2                            1009 test $0, %bx
    0     2                            1010 jgt .top
    0     2   ------ Interrupt ------  ------ Interrupt ------  
    0     2   1011 halt
    0     2   ----- Halt;Switch -----  ----- Halt;Switch -----  
    0     2                            1011 halt

```

**28.5：现在让我们看看程序test-and-set.s。首先，尝试理解使用xchg 指令构建简单锁原语的代码。获取锁怎么写？释放锁如何写？**

汇编代码如下，xchg指令交换ax（1）和mutex的值，如果当前锁未被持有，则ax会返回0，并且mutex置1，成功获取锁。如果当前锁已被持有，则ax返回1，继续尝试获取锁。释放锁即将mutex修改为0

```c
.var mutex
.var count

.main
.top	

.acquire
mov  $1, %ax        
xchg %ax, mutex     #原子地交换ax%和mutex的值
test $0, %ax        #如果返回0，则说明锁还未被持有，获取锁。
jne  .acquire       

# critical section
mov  count, %ax     # get the value at the address
add  $1, %ax        # increment it
mov  %ax, count     # store it back

# release lock
mov  $0, mutex

# see if we're still looping
sub  $1, %bx
test $0, %bx
jgt .top	

halt

```

**28.6：现在运行代码，再次更改中断间隔（-i）的值，并确保循环多次。代码是否总能按预期工作？有时会导致CPU 使用率不高吗？如何量化呢？**

分别运行命令行

python2 x86.py -p test-and-set.s -a bx=2,bx=2 -M count -c -i 1
python2 x86.py -p test-and-set.s -a bx=2,bx=2 -M count -c -i 2
python2 x86.py -p test-and-set.s -a bx=2,bx=2 -M count -c -i 3

可以得出结论

代码是否总能按预期工作, 单核cpu情况下,当一个线程持有锁进入临界区时被抢占,抢占的线程将会自旋一个时间片,导致cpu利用率不高,
量化:计算 当一个线程持有锁进入临界区时被抢占,抢占线程的自旋时间长与总时间长百分比即可

**28.7：使用-P 标志生成锁相关代码的特定测试。例如，执行一个测试计划，在第一个线程中获取锁，但随后尝试在第二个线程中获取锁。正确的事情发生了吗？**

执行命令行`python2 x86.py -p test-and-set.s -M mutex,count -R ax,ybx -c -a bx=2,bx=2 -P 0011111`

运行结果如下：

可以看到线程0先获取了锁，这时候发生中断，切换到线程1，尝试获取锁失败。但线程0释放锁后，线程1才成功获取锁，运行结果正确。

```c
mutex count      ax    bx          Thread 0                Thread 1         

    0     0       0     2   
    0     0       1     2   1000 mov  $1, %ax
    1     0       0     2   1001 xchg %ax, mutex
    1     0       0     2   ------ Interrupt ------  ------ Interrupt ------  
    1     0       1     2                            1000 mov  $1, %ax
    1     0       1     2                            1001 xchg %ax, mutex
    1     0       1     2                            1002 test $0, %ax
    1     0       1     2                            1003 jne  .acquire
    1     0       1     2                            1000 mov  $1, %ax
    1     0       0     2   ------ Interrupt ------  ------ Interrupt ------  
    1     0       0     2   1002 test $0, %ax
    1     0       0     2   1003 jne  .acquire
    1     0       1     2   ------ Interrupt ------  ------ Interrupt ------  
    1     0       1     2                            1001 xchg %ax, mutex
    1     0       1     2                            1002 test $0, %ax
    1     0       1     2                            1003 jne  .acquire
    1     0       1     2                            1000 mov  $1, %ax
    1     0       1     2                            1001 xchg %ax, mutex
    1     0       0     2   ------ Interrupt ------  ------ Interrupt ------  
    1     0       0     2   1004 mov  count, %ax
    1     0       1     2   1005 add  $1, %ax
    1     0       1     2   ------ Interrupt ------  ------ Interrupt ------  
    1     0       1     2                            1002 test $0, %ax
    1     0       1     2                            1003 jne  .acquire
    1     0       1     2                            1000 mov  $1, %ax
    1     0       1     2                            1001 xchg %ax, mutex
    1     0       1     2                            1002 test $0, %ax
    1     0       1     2   ------ Interrupt ------  ------ Interrupt ------  
    1     1       1     2   1006 mov  %ax, count
    0     1       1     2   1007 mov  $0, mutex
    0     1       1     2   ------ Interrupt ------  ------ Interrupt ------  
    0     1       1     2                            1003 jne  .acquire
    0     1       1     2                            1000 mov  $1, %ax
    1     1       0     2                            1001 xchg %ax, mutex
    1     1       0     2                            1002 test $0, %ax
    1     1       0     2                            1003 jne  .acquire
    1     1       1     2   ------ Interrupt ------  ------ Interrupt ------  
    1     1       1     1   1008 sub  $1, %bx
    1     1       1     1   1009 test $0, %bx
    1     1       0     2   ------ Interrupt ------  ------ Interrupt ------  
    1     1       1     2                            1004 mov  count, %ax
    1     1       2     2                            1005 add  $1, %ax
    1     2       2     2                            1006 mov  %ax, count
    0     2       2     2                            1007 mov  $0, mutex
    0     2       2     1                            1008 sub  $1, %bx
    0     2       1     1   ------ Interrupt ------  ------ Interrupt ------  
    0     2       1     1   1010 jgt .top
    0     2       1     1   1000 mov  $1, %ax
    0     2       2     1   ------ Interrupt ------  ------ Interrupt ------  
    0     2       2     1                            1009 test $0, %bx
    0     2       2     1                            1010 jgt .top
    0     2       1     1                            1000 mov  $1, %ax
    1     2       0     1                            1001 xchg %ax, mutex
    1     2       0     1                            1002 test $0, %ax
    1     2       1     1   ------ Interrupt ------  ------ Interrupt ------  
    1     2       1     1   1001 xchg %ax, mutex
    1     2       1     1   1002 test $0, %ax
    1     2       0     1   ------ Interrupt ------  ------ Interrupt ------  
    1     2       0     1                            1003 jne  .acquire
    1     2       2     1                            1004 mov  count, %ax
    1     2       3     1                            1005 add  $1, %ax
    1     3       3     1                            1006 mov  %ax, count
    0     3       3     1                            1007 mov  $0, mutex
    0     3       1     1   ------ Interrupt ------  ------ Interrupt ------  
    0     3       1     1   1003 jne  .acquire
    0     3       1     1   1000 mov  $1, %ax
    0     3       3     1   ------ Interrupt ------  ------ Interrupt ------  
    0     3       3     0                            1008 sub  $1, %bx
    0     3       3     0                            1009 test $0, %bx
    0     3       3     0                            1010 jgt .top
    0     3       3     0                            1011 halt
    0     3       1     1   ----- Halt;Switch -----  ----- Halt;Switch -----  
    1     3       0     1   1001 xchg %ax, mutex
    1     3       0     1   1002 test $0, %ax
    1     3       0     1   1003 jne  .acquire
    1     3       3     1   1004 mov  count, %ax
    1     3       4     1   1005 add  $1, %ax
    1     4       4     1   1006 mov  %ax, count
    0     4       4     1   1007 mov  $0, mutex
    0     4       4     0   1008 sub  $1, %bx
    0     4       4     0   1009 test $0, %bx
    0     4       4     0   1010 jgt .top
    0     4       4     0   1011 halt

```



## 第30章

#### **30.1**

**我们的第一个问题集中在 main-two-cvs-while.c（有效的解决方案）上。 首先，研究代码。 你认为你了解当你运行程序时会发生什么吗？**

程序实现了一个典型的单值缓冲区生产者消费者问题，生产者把生成的数据项放入缓冲区；消费者从缓冲区取走数据项。并且保证了临界区的原子操作。

运行`./main-two-cvs-while -l 3 -m 2 -p 1 -c 1 -v`结果如下：



```
  NF             P0 C0 
  0 [*---  --- ] p0
  0 [*---  --- ]    c0
  0 [*---  --- ]    c1
  0 [*---  --- ]    c2
  0 [*---  --- ] p1
  1 [u  0 f--- ] p4
  1 [u  0 f--- ] p5
  1 [u  0 f--- ] p6
  1 [u  0 f--- ]    c3
  0 [ --- *--- ]    c4
  0 [ --- *--- ] p0
  0 [ --- *--- ]    c5
  0 [ --- *--- ]    c6
  0 [ --- *--- ] p1
  0 [ --- *--- ]    c0
  1 [f--- u  1 ] p4
  1 [f--- u  1 ] p5
  1 [f--- u  1 ] p6
  1 [f--- u  1 ]    c1
  0 [*---  --- ]    c4
  0 [*---  --- ] p0
  0 [*---  --- ]    c5
  0 [*---  --- ]    c6
  0 [*---  --- ] p1
  0 [*---  --- ]    c0
  1 [u  2 f--- ] p4
  1 [u  2 f--- ] p5
  1 [u  2 f--- ] p6
  1 [u  2 f--- ]    c1
  0 [ --- *--- ]    c4
  0 [ --- *--- ]    c5
  0 [ --- *--- ]    c6
  1 [f--- uEOS ] [main: added end-of-stream marker]
  1 [f--- uEOS ]    c0
  1 [f--- uEOS ]    c1
  0 [*---  --- ]    c4
  0 [*---  --- ]    c5
  0 [*---  --- ]    c6

Consumer consumption:
  C0 -> 3

```

参数说明

```
  -l <number of items each producer produces>
  -m <size of the shared producer/consumer buffer>
  -p <number of producers>
  -c <number of consumers>
  -P <sleep string: how each producer should sleep at various points in execution>
  -C <sleep string: how each consumer should sleep at various points in execution>
  -v [ verbose flag: trace what is happening and print it ]
  -t [ timing flag: time entire execution and print total time ]

```

#### **30.2**

**指定一个生产者和一个消费者运行，并让生产者产生一些元素。** 
**缓冲区大小从 1 开始，然后增加。随着缓冲区大小增加，程序运行结果如何改变？**

**当使用不同的缓冲区大小(例如 -m 10)，生产者生产不同的产品数量(例如 -l 100)，**
**修改消费者的睡眠字符串(例如 -C 0,0,0,0,0,0,1)，full_num 的值如何变化？**

1.运行

`./main-two-cvs-while -l 3 -m 1 -p 1 -c 1 -v`
`./main-two-cvs-while -l 3 -m 2 -p 1 -c 1 -v`
`./main-two-cvs-while -l 3 -m 3 -p 1 -c 1 -v`
`./main-two-cvs-while -l 3 -m 4 -p 1 -c 1 -v`

从运行结果可以看出，每次消费者的消费总量都为3，full num 都为0

```
nnilk@nnilk-VirtualBox:~/文档/ostep-homework/threads-cv$ ./main-two-cvs-while -l 3 -m 1 -p 1 -c 1 -v
 NF        P0 C0 
  0 [*--- ] p0
  0 [*--- ]    c0
  0 [*--- ]    c1
  0 [*--- ]    c2
  0 [*--- ] p1
  1 [*  0 ] p4
  1 [*  0 ] p5
  1 [*  0 ] p6
  1 [*  0 ]    c3
  1 [*  0 ] p0
  0 [*--- ]    c4
  0 [*--- ]    c5
  0 [*--- ]    c6
  0 [*--- ] p1
  1 [*  1 ] p4
  1 [*  1 ]    c0
  1 [*  1 ] p5
  1 [*  1 ] p6
  1 [*  1 ]    c1
  1 [*  1 ] p0
  0 [*--- ]    c4
  0 [*--- ]    c5
  0 [*--- ]    c6
  0 [*--- ] p1
  0 [*--- ]    c0
  1 [*  2 ] p4
  1 [*  2 ] p5
  1 [*  2 ] p6
  1 [*  2 ]    c1
  0 [*--- ]    c4
  0 [*--- ]    c5
  1 [*EOS ] [main: added end-of-stream marker]
  1 [*EOS ]    c6
  1 [*EOS ]    c0
  1 [*EOS ]    c1
  0 [*--- ]    c4
  0 [*--- ]    c5
  0 [*--- ]    c6

Consumer consumption:
  C0 -> 3

nnilk@nnilk-VirtualBox:~/文档/ostep-homework/threads-cv$ ./main-two-cvs-while -l 3 -m 2 -p 1 -c 1 -v
 NF             P0 C0 
  0 [*---  --- ] p0
  0 [*---  --- ]    c0
  0 [*---  --- ]    c1
  0 [*---  --- ]    c2
  0 [*---  --- ] p1
  1 [u  0 f--- ] p4
  1 [u  0 f--- ] p5
  1 [u  0 f--- ] p6
  1 [u  0 f--- ] p0
  1 [u  0 f--- ]    c3
  0 [ --- *--- ]    c4
  0 [ --- *--- ]    c5
  0 [ --- *--- ]    c6
  0 [ --- *--- ] p1
  0 [ --- *--- ]    c0
  1 [f--- u  1 ] p4
  1 [f--- u  1 ] p5
  1 [f--- u  1 ] p6
  1 [f--- u  1 ]    c1
  0 [*---  --- ]    c4
  0 [*---  --- ] p0
  0 [*---  --- ]    c5
  0 [*---  --- ]    c6
  0 [*---  --- ] p1
  1 [u  2 f--- ] p4
  1 [u  2 f--- ]    c0
  1 [u  2 f--- ] p5
  1 [u  2 f--- ] p6
  1 [u  2 f--- ]    c1
  0 [ --- *--- ]    c4
  0 [ --- *--- ]    c5
  0 [ --- *--- ]    c6
  1 [f--- uEOS ] [main: added end-of-stream marker]
  1 [f--- uEOS ]    c0
  1 [f--- uEOS ]    c1
  0 [*---  --- ]    c4
  0 [*---  --- ]    c5
  0 [*---  --- ]    c6

Consumer consumption:
  C0 -> 3

nnilk@nnilk-VirtualBox:~/文档/ostep-homework/threads-cv$ ./main-two-cvs-while -l 3 -m 3 -p 1 -c 1 -v
 NF                  P0 C0 
  0 [*---  ---  --- ] p0
  0 [*---  ---  --- ]    c0
  0 [*---  ---  --- ]    c1
  0 [*---  ---  --- ]    c2
  0 [*---  ---  --- ] p1
  1 [u  0 f---  --- ] p4
  1 [u  0 f---  --- ] p5
  1 [u  0 f---  --- ] p6
  1 [u  0 f---  --- ]    c3
  0 [ --- *---  --- ]    c4
  0 [ --- *---  --- ] p0
  0 [ --- *---  --- ]    c5
  0 [ --- *---  --- ]    c6
  0 [ --- *---  --- ] p1
  0 [ --- *---  --- ]    c0
  1 [ --- u  1 f--- ] p4
  1 [ --- u  1 f--- ] p5
  1 [ --- u  1 f--- ] p6
  1 [ --- u  1 f--- ]    c1
  0 [ ---  --- *--- ]    c4
  0 [ ---  --- *--- ] p0
  0 [ ---  --- *--- ]    c5
  0 [ ---  --- *--- ]    c6
  0 [ ---  --- *--- ] p1
  1 [f---  --- u  2 ] p4
  1 [f---  --- u  2 ]    c0
  1 [f---  --- u  2 ] p5
  1 [f---  --- u  2 ] p6
  1 [f---  --- u  2 ]    c1
  0 [*---  ---  --- ]    c4
  0 [*---  ---  --- ]    c5
  0 [*---  ---  --- ]    c6
  1 [uEOS f---  --- ] [main: added end-of-stream marker]
  1 [uEOS f---  --- ]    c0
  1 [uEOS f---  --- ]    c1
  0 [ --- *---  --- ]    c4
  0 [ --- *---  --- ]    c5
  0 [ --- *---  --- ]    c6

Consumer consumption:
  C0 -> 3

nnilk@nnilk-VirtualBox:~/文档/ostep-homework/threads-cv$ ./main-two-cvs-while -l 3 -m 4 -p 1 -c 1 -v
 NF                       P0 C0 
  0 [*---  ---  ---  --- ] p0
  0 [*---  ---  ---  --- ]    c0
  0 [*---  ---  ---  --- ]    c1
  0 [*---  ---  ---  --- ]    c2
  0 [*---  ---  ---  --- ] p1
  1 [u  0 f---  ---  --- ] p4
  1 [u  0 f---  ---  --- ] p5
  1 [u  0 f---  ---  --- ] p6
  1 [u  0 f---  ---  --- ] p0
  1 [u  0 f---  ---  --- ]    c3
  0 [ --- *---  ---  --- ]    c4
  0 [ --- *---  ---  --- ]    c5
  0 [ --- *---  ---  --- ]    c6
  0 [ --- *---  ---  --- ] p1
  1 [ --- u  1 f---  --- ] p4
  1 [ --- u  1 f---  --- ]    c0
  1 [ --- u  1 f---  --- ] p5
  1 [ --- u  1 f---  --- ] p6
  1 [ --- u  1 f---  --- ]    c1
  1 [ --- u  1 f---  --- ] p0
  0 [ ---  --- *---  --- ]    c4
  0 [ ---  --- *---  --- ]    c5
  0 [ ---  --- *---  --- ]    c6
  0 [ ---  --- *---  --- ]    c0
  0 [ ---  --- *---  --- ] p1
  1 [ ---  --- u  2 f--- ] p4
  1 [ ---  --- u  2 f--- ] p5
  1 [ ---  --- u  2 f--- ] p6
  1 [ ---  --- u  2 f--- ]    c1
  0 [ ---  ---  --- *--- ]    c4
  0 [ ---  ---  --- *--- ]    c5
  1 [f---  ---  --- uEOS ] [main: added end-of-stream marker]
  1 [f---  ---  --- uEOS ]    c6
  1 [f---  ---  --- uEOS ]    c0
  1 [f---  ---  --- uEOS ]    c1
  0 [*---  ---  ---  --- ]    c4
  0 [*---  ---  ---  --- ]    c5
  0 [*---  ---  ---  --- ]    c6

Consumer consumption:
  C0 -> 3

```

运行以下命令行

`./main-two-cvs-while -l 4 -m 10 -p 1 -c 1 -v -C 0,0,0,0,0,0,1`
`./main-two-cvs-while -l 4 -m 10 -p 1 -c 1 -v -C 1,0,2,0,0,0,1`
`./main-two-cvs-while -l 4 -m 10 -p 1 -c 1 -v -C 0,1,0,0,0,0,1`
`./main-two-cvs-while -l 4 -m 10 -p 1 -c 1 -v -C 0,0,2,0,0,0,1`

从运行结果来看，保证生产者每次的生产数量和缓存区的大小不变，修改消费者的睡眠字符串，最终的full num仍然不会发生改变，为0.消费者的消费总量为4

```
nnilk@nnilk-VirtualBox:~/文档/ostep-homework/threads-cv$ ./main-two-cvs-while -l 4 -m 10 -p 1 -c 1 -v -C 0,0,0,0,0,0,1
 NF                                                     P0 C0 
  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ]    c0
  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ]    c1
  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ] p0
  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ]    c2
  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ] p1
  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p4
  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p5
  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p6
  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p0
  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ]    c3
  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c4
  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c5
  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c6
  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ] p1
  1 [ --- u  1 f---  ---  ---  ---  ---  ---  ---  --- ] p4
  1 [ --- u  1 f---  ---  ---  ---  ---  ---  ---  --- ] p5
  1 [ --- u  1 f---  ---  ---  ---  ---  ---  ---  --- ] p6
  1 [ --- u  1 f---  ---  ---  ---  ---  ---  ---  --- ] p0
  1 [ --- u  1 f---  ---  ---  ---  ---  ---  ---  --- ] p1
  2 [ --- u  1    2 f---  ---  ---  ---  ---  ---  --- ] p4
  2 [ --- u  1    2 f---  ---  ---  ---  ---  ---  --- ] p5
  2 [ --- u  1    2 f---  ---  ---  ---  ---  ---  --- ] p6
  2 [ --- u  1    2 f---  ---  ---  ---  ---  ---  --- ] p0
  2 [ --- u  1    2 f---  ---  ---  ---  ---  ---  --- ] p1
  3 [ --- u  1    2    3 f---  ---  ---  ---  ---  --- ] p4
  3 [ --- u  1    2    3 f---  ---  ---  ---  ---  --- ] p5
  3 [ --- u  1    2    3 f---  ---  ---  ---  ---  --- ] p6
  4 [ --- u  1    2    3  EOS f---  ---  ---  ---  --- ] [main: added end-of-stream marker]
  4 [ --- u  1    2    3  EOS f---  ---  ---  ---  --- ]    c0
  4 [ --- u  1    2    3  EOS f---  ---  ---  ---  --- ]    c1
  3 [ ---  --- u  2    3  EOS f---  ---  ---  ---  --- ]    c4
  3 [ ---  --- u  2    3  EOS f---  ---  ---  ---  --- ]    c5
  3 [ ---  --- u  2    3  EOS f---  ---  ---  ---  --- ]    c6
  3 [ ---  --- u  2    3  EOS f---  ---  ---  ---  --- ]    c0
  3 [ ---  --- u  2    3  EOS f---  ---  ---  ---  --- ]    c1
  2 [ ---  ---  --- u  3  EOS f---  ---  ---  ---  --- ]    c4
  2 [ ---  ---  --- u  3  EOS f---  ---  ---  ---  --- ]    c5
  2 [ ---  ---  --- u  3  EOS f---  ---  ---  ---  --- ]    c6
  2 [ ---  ---  --- u  3  EOS f---  ---  ---  ---  --- ]    c0
  2 [ ---  ---  --- u  3  EOS f---  ---  ---  ---  --- ]    c1
  1 [ ---  ---  ---  --- uEOS f---  ---  ---  ---  --- ]    c4
  1 [ ---  ---  ---  --- uEOS f---  ---  ---  ---  --- ]    c5
  1 [ ---  ---  ---  --- uEOS f---  ---  ---  ---  --- ]    c6
  1 [ ---  ---  ---  --- uEOS f---  ---  ---  ---  --- ]    c0
  1 [ ---  ---  ---  --- uEOS f---  ---  ---  ---  --- ]    c1
  0 [ ---  ---  ---  ---  --- *---  ---  ---  ---  --- ]    c4
  0 [ ---  ---  ---  ---  --- *---  ---  ---  ---  --- ]    c5
  0 [ ---  ---  ---  ---  --- *---  ---  ---  ---  --- ]    c6

Consumer consumption:
  C0 -> 4

nnilk@nnilk-VirtualBox:~/文档/ostep-homework/threads-cv$ ./main-two-cvs-while -l 4 -m 10 -p 1 -c 1 -v -C 1,0,2,0,0,0,1
 NF                                                     P0 C0 
  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ] p0
  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ]    c0
  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ] p1
  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p4
  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p5
  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p6
  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p0
  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p1
  2 [u  0    1 f---  ---  ---  ---  ---  ---  ---  --- ] p4
  2 [u  0    1 f---  ---  ---  ---  ---  ---  ---  --- ] p5
  2 [u  0    1 f---  ---  ---  ---  ---  ---  ---  --- ] p6
  2 [u  0    1 f---  ---  ---  ---  ---  ---  ---  --- ] p0
  2 [u  0    1 f---  ---  ---  ---  ---  ---  ---  --- ] p1
  3 [u  0    1    2 f---  ---  ---  ---  ---  ---  --- ] p4
  3 [u  0    1    2 f---  ---  ---  ---  ---  ---  --- ] p5
  3 [u  0    1    2 f---  ---  ---  ---  ---  ---  --- ] p6
  3 [u  0    1    2 f---  ---  ---  ---  ---  ---  --- ] p0
  3 [u  0    1    2 f---  ---  ---  ---  ---  ---  --- ] p1
  4 [u  0    1    2    3 f---  ---  ---  ---  ---  --- ] p4
  4 [u  0    1    2    3 f---  ---  ---  ---  ---  --- ] p5
  4 [u  0    1    2    3 f---  ---  ---  ---  ---  --- ] p6
  5 [u  0    1    2    3  EOS f---  ---  ---  ---  --- ] [main: added end-of-stream marker]
  5 [u  0    1    2    3  EOS f---  ---  ---  ---  --- ]    c1
  4 [ --- u  1    2    3  EOS f---  ---  ---  ---  --- ]    c4
  4 [ --- u  1    2    3  EOS f---  ---  ---  ---  --- ]    c5
  4 [ --- u  1    2    3  EOS f---  ---  ---  ---  --- ]    c6
  4 [ --- u  1    2    3  EOS f---  ---  ---  ---  --- ]    c0
  4 [ --- u  1    2    3  EOS f---  ---  ---  ---  --- ]    c1
  3 [ ---  --- u  2    3  EOS f---  ---  ---  ---  --- ]    c4
  3 [ ---  --- u  2    3  EOS f---  ---  ---  ---  --- ]    c5
  3 [ ---  --- u  2    3  EOS f---  ---  ---  ---  --- ]    c6
  3 [ ---  --- u  2    3  EOS f---  ---  ---  ---  --- ]    c0
  3 [ ---  --- u  2    3  EOS f---  ---  ---  ---  --- ]    c1
  2 [ ---  ---  --- u  3  EOS f---  ---  ---  ---  --- ]    c4
  2 [ ---  ---  --- u  3  EOS f---  ---  ---  ---  --- ]    c5
  2 [ ---  ---  --- u  3  EOS f---  ---  ---  ---  --- ]    c6
  2 [ ---  ---  --- u  3  EOS f---  ---  ---  ---  --- ]    c0
  2 [ ---  ---  --- u  3  EOS f---  ---  ---  ---  --- ]    c1
  1 [ ---  ---  ---  --- uEOS f---  ---  ---  ---  --- ]    c4
  1 [ ---  ---  ---  --- uEOS f---  ---  ---  ---  --- ]    c5
  1 [ ---  ---  ---  --- uEOS f---  ---  ---  ---  --- ]    c6
  1 [ ---  ---  ---  --- uEOS f---  ---  ---  ---  --- ]    c0
  1 [ ---  ---  ---  --- uEOS f---  ---  ---  ---  --- ]    c1
  0 [ ---  ---  ---  ---  --- *---  ---  ---  ---  --- ]    c4
  0 [ ---  ---  ---  ---  --- *---  ---  ---  ---  --- ]    c5
  0 [ ---  ---  ---  ---  --- *---  ---  ---  ---  --- ]    c6

Consumer consumption:
  C0 -> 4

nnilk@nnilk-VirtualBox:~/文档/ostep-homework/threads-cv$ ./main-two-cvs-while -l 4 -m 10 -p 1 -c 1 -v -C 0,1,0,0,0,0,1
 NF                                                     P0 C0 
  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ]    c0
  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ] p0
  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ]    c1
  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ]    c2
  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ] p1
  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p4
  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p5
  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ]    c3
  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p6
  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c4
  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ] p0
  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c5
  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c6
  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ] p1
  1 [ --- u  1 f---  ---  ---  ---  ---  ---  ---  --- ] p4
  1 [ --- u  1 f---  ---  ---  ---  ---  ---  ---  --- ] p5
  1 [ --- u  1 f---  ---  ---  ---  ---  ---  ---  --- ] p6
  1 [ --- u  1 f---  ---  ---  ---  ---  ---  ---  --- ] p0
  1 [ --- u  1 f---  ---  ---  ---  ---  ---  ---  --- ] p1
  2 [ --- u  1    2 f---  ---  ---  ---  ---  ---  --- ] p4
  2 [ --- u  1    2 f---  ---  ---  ---  ---  ---  --- ] p5
  2 [ --- u  1    2 f---  ---  ---  ---  ---  ---  --- ] p6
  2 [ --- u  1    2 f---  ---  ---  ---  ---  ---  --- ] p0
  2 [ --- u  1    2 f---  ---  ---  ---  ---  ---  --- ] p1
  3 [ --- u  1    2    3 f---  ---  ---  ---  ---  --- ] p4
  3 [ --- u  1    2    3 f---  ---  ---  ---  ---  --- ] p5
  3 [ --- u  1    2    3 f---  ---  ---  ---  ---  --- ] p6
  4 [ --- u  1    2    3  EOS f---  ---  ---  ---  --- ] [main: added end-of-stream marker]
  4 [ --- u  1    2    3  EOS f---  ---  ---  ---  --- ]    c0
  4 [ --- u  1    2    3  EOS f---  ---  ---  ---  --- ]    c1
  3 [ ---  --- u  2    3  EOS f---  ---  ---  ---  --- ]    c4
  3 [ ---  --- u  2    3  EOS f---  ---  ---  ---  --- ]    c5
  3 [ ---  --- u  2    3  EOS f---  ---  ---  ---  --- ]    c6
  3 [ ---  --- u  2    3  EOS f---  ---  ---  ---  --- ]    c0
  3 [ ---  --- u  2    3  EOS f---  ---  ---  ---  --- ]    c1
  2 [ ---  ---  --- u  3  EOS f---  ---  ---  ---  --- ]    c4
  2 [ ---  ---  --- u  3  EOS f---  ---  ---  ---  --- ]    c5
  2 [ ---  ---  --- u  3  EOS f---  ---  ---  ---  --- ]    c6
  2 [ ---  ---  --- u  3  EOS f---  ---  ---  ---  --- ]    c0
  2 [ ---  ---  --- u  3  EOS f---  ---  ---  ---  --- ]    c1
  1 [ ---  ---  ---  --- uEOS f---  ---  ---  ---  --- ]    c4
  1 [ ---  ---  ---  --- uEOS f---  ---  ---  ---  --- ]    c5
  1 [ ---  ---  ---  --- uEOS f---  ---  ---  ---  --- ]    c6
  1 [ ---  ---  ---  --- uEOS f---  ---  ---  ---  --- ]    c0
  1 [ ---  ---  ---  --- uEOS f---  ---  ---  ---  --- ]    c1
  0 [ ---  ---  ---  ---  --- *---  ---  ---  ---  --- ]    c4
  0 [ ---  ---  ---  ---  --- *---  ---  ---  ---  --- ]    c5
  0 [ ---  ---  ---  ---  --- *---  ---  ---  ---  --- ]    c6

Consumer consumption:
  C0 -> 4

nnilk@nnilk-VirtualBox:~/文档/ostep-homework/threads-cv$ ./main-two-cvs-while -l 4 -m 10 -p 1 -c 1 -v -C 0,0,2,0,0,0,1
 NF                                                     P0 C0 
  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ] p0
  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ]    c0
  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ] p1
  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p4
  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p5
  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p6
  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ]    c1
  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p0
  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c4
  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c5
  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c6
  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ] p1
  1 [ --- u  1 f---  ---  ---  ---  ---  ---  ---  --- ] p4
  1 [ --- u  1 f---  ---  ---  ---  ---  ---  ---  --- ] p5
  1 [ --- u  1 f---  ---  ---  ---  ---  ---  ---  --- ] p6
  1 [ --- u  1 f---  ---  ---  ---  ---  ---  ---  --- ] p0
  1 [ --- u  1 f---  ---  ---  ---  ---  ---  ---  --- ] p1
  2 [ --- u  1    2 f---  ---  ---  ---  ---  ---  --- ] p4
  2 [ --- u  1    2 f---  ---  ---  ---  ---  ---  --- ] p5
  2 [ --- u  1    2 f---  ---  ---  ---  ---  ---  --- ] p6
  2 [ --- u  1    2 f---  ---  ---  ---  ---  ---  --- ] p0
  2 [ --- u  1    2 f---  ---  ---  ---  ---  ---  --- ] p1
  3 [ --- u  1    2    3 f---  ---  ---  ---  ---  --- ] p4
  3 [ --- u  1    2    3 f---  ---  ---  ---  ---  --- ] p5
  3 [ --- u  1    2    3 f---  ---  ---  ---  ---  --- ] p6
  4 [ --- u  1    2    3  EOS f---  ---  ---  ---  --- ] [main: added end-of-stream marker]
  4 [ --- u  1    2    3  EOS f---  ---  ---  ---  --- ]    c0
  4 [ --- u  1    2    3  EOS f---  ---  ---  ---  --- ]    c1
  3 [ ---  --- u  2    3  EOS f---  ---  ---  ---  --- ]    c4
  3 [ ---  --- u  2    3  EOS f---  ---  ---  ---  --- ]    c5
  3 [ ---  --- u  2    3  EOS f---  ---  ---  ---  --- ]    c6
  3 [ ---  --- u  2    3  EOS f---  ---  ---  ---  --- ]    c0
  3 [ ---  --- u  2    3  EOS f---  ---  ---  ---  --- ]    c1
  2 [ ---  ---  --- u  3  EOS f---  ---  ---  ---  --- ]    c4
  2 [ ---  ---  --- u  3  EOS f---  ---  ---  ---  --- ]    c5
  2 [ ---  ---  --- u  3  EOS f---  ---  ---  ---  --- ]    c6
  2 [ ---  ---  --- u  3  EOS f---  ---  ---  ---  --- ]    c0
  2 [ ---  ---  --- u  3  EOS f---  ---  ---  ---  --- ]    c1
  1 [ ---  ---  ---  --- uEOS f---  ---  ---  ---  --- ]    c4
  1 [ ---  ---  ---  --- uEOS f---  ---  ---  ---  --- ]    c5
  1 [ ---  ---  ---  --- uEOS f---  ---  ---  ---  --- ]    c6
  1 [ ---  ---  ---  --- uEOS f---  ---  ---  ---  --- ]    c0
  1 [ ---  ---  ---  --- uEOS f---  ---  ---  ---  --- ]    c1
  0 [ ---  ---  ---  ---  --- *---  ---  ---  ---  --- ]    c4
  0 [ ---  ---  ---  ---  --- *---  ---  ---  ---  --- ]    c5
  0 [ ---  ---  ---  ---  --- *---  ---  ---  ---  --- ]    c6

Consumer consumption:
  C0 -> 4

```

#### **30.4**

**我们来看一些 timings。 对于一个生产者，三个消费者，大小为 1 的共享缓冲区以及每个消费者在 c3 点暂停一秒，您认为需要执行多长时间？**

指定一个生产者，三个消费者，缓冲区大小为 1 ，消费者睡眠串均为`0，0，0，1，0，0`

`./main-two-cvs-while -p 1 -c 3 -m 1 -C 0,0,0,1,0,0,0:0,0,0,1,0,0,0:0,0,0,1,0,0,0 -l 10 -v -t`

运行结果如下：

如果消费者线程先执行，那么执行时间为 13s，

如果生产者者线程先执行，那么执行时间为 12s

```
nnilk@nnilk-VirtualBox:~/文档/ostep-homework/threads-cv$ ./main-two-cvs-while -p 1 -c 3 -m 1 -C 0,0,0,1,0,0,0:0,0,0,1,0,0,0:0,0,0,1,0,0,0 -l 10 -v -t
 NF        P0 C0 C1 C2 
  0 [*--- ] p0
  0 [*--- ]    c0
  0 [*--- ]       c0
  0 [*--- ]          c0
  0 [*--- ] p1
   ...
   ...
  1 [*EOS ]       c3
  0 [*--- ]       c4
  0 [*--- ]       c5
  0 [*--- ]       c6

Consumer consumption:
  C0 -> 1
  C1 -> 2
  C2 -> 7

Total time: 12.04 seconds

nnilk@nnilk-VirtualBox:~/文档/ostep-homework/threads-cv$ ./main-two-cvs-while -p 1 -c 3 -m 1 -C 0,0,0,1,0,0,0:0,0,0,1,0,0,0:0,0,0,1,0,0,0 -l 10 -v -t
 NF        P0 C0 C1 C2 
  0 [*--- ] p0
  0 [*--- ]    c0
  0 [*--- ]       c0
  0 [*--- ]          c0
  ...
  ...
  1 [*EOS ] [main: added end-of-stream marker]
  1 [*EOS ]       c6
  1 [*EOS ]    c3
  0 [*--- ]    c4
  0 [*--- ]    c5
  0 [*--- ]    c6

Consumer consumption:
  C0 -> 1
  C1 -> 0
  C2 -> 9

Total time: 13.07 seconds

```

**30.8**

**现在让我们看一下 main-one-cv-while.c。您是否可以假设只有一个生产者，一个消费者和一个大小为 1 的缓冲区，配置一个睡眠字符串，让代码运行出现问题**

main-one-cv-while.c没有实现一个单值缓冲区的生产消费者方案，只有一个条件变量cv，可能存在消费者唤醒消费者，生产者唤醒生产者的错误。

但是在只有一个消费者一个生产者的情况下，不会出现这种错误。所以无法配置一个睡眠字符串让代码运行出现问题。

**30.9**

**现在将消费者数量更改为两个。 为生产者消费者配置睡眠字符串，从而使代码运行出现问题**

无法配置睡眠字符串，使得代码运行必定出现问题，这取决于操作系统的线程调度    

即使不配置睡眠字符串，也可能出现如下情况：生产者生产后，缓冲区满了，唤醒了两个正在睡眠的消费者中的一个，然后进入睡眠（Mutex_lock）消费者消费后，唤醒另一个消费者，进入睡眠（Mutex_lock），新的消费者线程被唤醒，发现缓冲区为空，进入睡眠（Cond_wait）,此时三个线程都进入睡眠

**30.10**

**现在查看 main-two-cvs-if.c。 您是否可以配置一些参数让代码运行出现问题？ 再次考虑只有一个消费者的情况，然后再考虑有一个以上消费者的情况。**

main-two-cvs-if.c 使用if语句检查条件，存在一个问题   ，一个线程的被唤醒后，在运行之前，条件变量的值可能发生改变，所以if语句单次检查并不安全

先考虑一个消费者的情况，一旦消费者被唤醒，所有生产者都会处于睡眠状态，所以消费者被唤醒后会马上运行，所以不会存在代码运行出现问题的情况

考虑多个消费者的情况，当一个消费者C0被唤醒，在他运行之前，另一个消费者C1也被唤醒并抢先运行，消耗完了缓冲区的内存，此时消费者C0再运行便会发生错误

 `./main-two-cvs-if -m 1 -c 2 -p 1 -l 10 -C 2:0,0,0,3 -P 1` 会出现错误

**30.11**

**最后查看 main-two-cvs-while-extra-unlock.c。在向缓冲区添加或取出元素时释放锁时会出现什么问题？给定睡眠字符串来引起这类问题的发生？ 会造成什么不好的结果？**

程序 **main-two-cvs-while-extra-unlock.c** 将锁放在了do_fill() 和 do_get()之外，没有临界区操作的原子性

不需要配置睡眠字符串也会出现上述问题，这取决于操作系统的调度

## 第31章

#### **31.1**

**第一个问题是实现和测试fork/join问题的解决方案，如文中所述。即使在文本中描述了这个解决方案，自己输入它的行为是值得的。详见fork-join.c。向子进程添加sleep(1)调用，以确保它正在工作。**

```c
void *child(void *arg) {
    printf("child\n");
    sleep(1);//向子进程添加sleep(1)调用
    // use semaphore here
    return NULL;
}

```

程序运行结果如下：

```c
parent: begin
child
parent: end
```

#### **31.2**

**现在，我们通过研究集合点问题 [rendezvous problem](https://en.wikipedia.org/wiki/Rendezvous_problem) 来对此进行概括。** 
**问题如下：您有两个线程，每个线程将要在代码中进入集合点。 任何一方都不应在另一方进入之前退出代码的这一部分。该任务使用两个信号量，有关详细信息，请参见 rendezvous.c。**

补充程序代码

```c
#include <stdio.h>
#include <unistd.h>
#include "common_threads.h"
#include <semaphor
e.h>

// If done correctly, each child should print their "before" message
// before either prints their "after" message. Test by adding sleep(1)
// calls in various locations.

sem_t s1, s2;

void *child_1(void *arg) {
    printf("child 1: before\n");
    sleep(1);
    sem_post(&s2); //增加信号量s2、
    sem_wait(&s1); //等待信号量s1
    printf("child 1: after\n");
    return NULL;
}

void *child_2(void *arg) {
    printf("child 2: before\n");
    sleep(1);
    sem_post(&s1);
    sem_wait(&s2);
    printf("child 2: after\n");
    return NULL;
}

int main(int argc, char *argv[]) {
    pthread_t p1, p2;
    printf("parent: begin\n");
    sem_init(&s1, 0, 0);
    sem_init(&s2, 0, 0);
    Pthread_create(&p1, NULL, child_1, NULL);
    Pthread_create(&p2, NULL, child_2, NULL);
    Pthread_join(p1, NULL);
    Pthread_join(p2, NULL);
    printf("parent: end\n");
    return 0;
}


```

**程序运行结果如下：**

可以看到，每个child都在打印`after`之前打印了`before`

```c
parent: begin
child 1: before
child 2: before
child 2: after
child 1: after
parent: end
```

#### 31.4

**现在按照文本中所述，解决读者写者问题。 首先，不用考虑进程饥饿。 有关详细信息，请参见 reader-writer.c 中的代码。 将 sleep（）调用添加到您的代码中，以证明它可以按预期工作。 你能证明饥饿问题的存在吗？**

代码实现如下：

读者优先的实现方案，可能存在读者长时间占用CPU，导致写者饿死的情况

但是此代码不会存在写者饿死的情况，因为读者和写者都会通过循环尝试获取锁

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include "common_threads.h"
#include <semaphore.h>
//
// Your code goes in the structure and functions below
//

typedef struct __rwlock_t {
    sem_t lock;
    sem_t write_lock;
    int reader_number;
} rwlock_t;

//将读者锁和写者锁初始化为1
void rwlock_init(rwlock_t *rw) {
    sem_init(&rw->lock, 0, 1);
    sem_init(&rw->write_lock, 0, 1);
    rw->reader_number = 0;
}

void rwlock_acquire_readlock(rwlock_t *rw) {
    sleep(1);
    sem_wait(&rw->lock); 
    rw->reader_number++; 
    if (rw->reader_number == 1) {
        sem_wait(&rw->write_lock);//第一个读者获取writer_lock
    }
    sem_post(&rw->lock); 
}

void rwlock_release_readlock(rwlock_t *rw) {
    sem_wait(&rw->lock);  
    rw->reader_number--; 
    if (rw->reader_number == 0) {
        sem_post(&rw->write_lock); //最后一个读者释放writer_lock
    }
    sem_post(&rw->lock); 
}

void rwlock_acquire_writelock(rwlock_t *rw) {
    sleep(1);
    sem_wait(&rw->write_lock);
}

void rwlock_release_writelock(rwlock_t *rw) {
    sem_post(&rw->write_lock);
}

//
// Don't change the code below (just use it!)
// 

int loops;
int value = 0;

rwlock_t lock;

void *reader(void *arg) {
    int i;
    for (i = 0; i < loops; i++) {
        rwlock_acquire_readlock(&lock);
        printf("read %d\n", value);
        rwlock_release_readlock(&lock);
    }
    return NULL;
}

void *writer(void *arg) {
    int i;
    for (i = 0; i < loops; i++) {
        rwlock_acquire_writelock(&lock);
        value++;
        printf("write %d\n", value);
        rwlock_release_writelock(&lock);
    }
    return NULL;
}

int main(int argc, char *argv[]) {
    assert(argc == 4);
    int num_readers = atoi(argv[1]);
    int num_writers = atoi(argv[2]);
    loops = atoi(argv[3]);

    pthread_t pr[num_readers], pw[num_writers];

    rwlock_init(&lock);

    printf("begin\n");

    int i;
    for (i = 0; i < num_readers; i++)
        Pthread_create(&pr[i], NULL, reader, NULL);
    for (i = 0; i < num_writers; i++)
        Pthread_create(&pw[i], NULL, writer, NULL);

    for (i = 0; i < num_readers; i++)
        Pthread_join(pr[i], NULL);
    for (i = 0; i < num_writers; i++)
        Pthread_join(pw[i], NULL);

    printf("end: value %d\n", value);

    return 0;
}


```

运行结果：

`gcc reader-writer.c -Wall -pthread -g`
`./a.out 2 2 2`

（两个读者，两个写者，loop=2）

```c
begin
read 0
read 0
write 1
write 2
write 3
read 3
read 3
write 4
end: value 4
```

#### 31.5

让我们再次看一下读者写者问题，但这一次需要考虑进程饥饿。 您如何确保所有读者和写者运行？ 有关详细信息，请参见 reader-writer-nostarve.c。

代码实现如下 :

增加一把writing_waiting锁，

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include "common_threads.h"
#include <semaphore.h>
//
// Your code goes in the structure and functions below
//

typedef struct __rwlock_t {
    sem_t lock;
    sem_t write_lock;
    sem_t write_waiting;
    int reader_number;
} rwlock_t;


void rwlock_init(rwlock_t *rw) {
    sem_init(&rw->lock, 0, 1);
    sem_init(&rw->write_lock, 0, 1);
    sem_init(&rw->write_waiting, 0, 1);
    rw->reader_number = 0;
}

void rwlock_acquire_readlock(rwlock_t *rw) {
    sleep(1);
    sem_wait(&rw->write_waiting);
    sem_wait(&rw->lock);
    rw->reader_number++;

    if (rw->reader_number == 1) {
        sem_wait(&rw->write_lock);
    }
    sem_post(&rw->lock);
    sem_post(&rw->write_waiting);

}

void rwlock_release_readlock(rwlock_t *rw) {
    sem_wait(&rw->lock);
    rw->reader_number--;
    if (rw->reader_number == 0) {
        sem_post(&rw->write_lock);
    }

    sem_post(&rw->lock);
}

void rwlock_acquire_writelock(rwlock_t *rw) {
    sleep(1);
    sem_wait(&rw->write_waiting);
    sem_wait(&rw->write_lock);
    sem_post(&rw->write_waiting);
}

void rwlock_release_writelock(rwlock_t *rw) {
    sem_post(&rw->write_lock);
}

//
// Don't change the code below (just use it!)
//

int loops;
int value = 0;

rwlock_t lock;

void *reader(void *arg) {
    int i;
    for (i = 0; i < loops; i++) {
        rwlock_acquire_readlock(&lock);
        printf("read %d\n", value);
        rwlock_release_readlock(&lock);
    }
    return NULL;
}

void *writer(void *arg) {
    int i;
    for (i = 0; i < loops; i++) {
        rwlock_acquire_writelock(&lock);
        value++;
        printf("write %d\n", value);
        rwlock_release_writelock(&lock);
    }
    return NULL;
}

int main(int argc, char *argv[]) {
    assert(argc == 4);
    int num_readers = atoi(argv[1]);
    int num_writers = atoi(argv[2]);
    loops = atoi(argv[3]);

    pthread_t pr[num_readers], pw[num_writers];

    rwlock_init(&lock);

    printf("begin\n");

    int i;
    for (i = 0; i < num_readers; i++)
        Pthread_create(&pr[i], NULL, reader, NULL);
    for (i = 0; i < num_writers; i++)
        Pthread_create(&pw[i], NULL, writer, NULL);

    for (i = 0; i < num_readers; i++)
        Pthread_join(pr[i], NULL);
    for (i = 0; i < num_writers; i++)
        Pthread_join(pw[i], NULL);

    printf("end: value %d\n", value);

    return 0;
}


```

#### 31.6

**使用信号量构建一个没有饥饿的互斥量，其中任何试图获取该互斥量的线程都将最终获得它。 有关更多信息，请参见 mutex-nostarve.c 中的代码。**

代码实现如下

在每次释放锁之后，确认所有线程都执行过临界区后再继续执行

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>
#include "common_threads.h"
#include "semaphore.h"
//
// Here, you have to write (almost) ALL the code. Oh no!
// How can you show that a thread does not starve
// when attempting to acquire this mutex you build?
//

typedef struct __ns_mutex_t {
    sem_t mutex;
    sem_t barrier;
    sem_t lock;
    int num_threads;
} ns_mutex_t;

ns_mutex_t m;

void ns_mutex_init(ns_mutex_t *m, int num_threads) {
    sem_init(&m->barrier, 0, -num_threads + 1);
    sem_init(&m->mutex, 0, 1);//互斥锁
}

void ns_mutex_acquire(ns_mutex_t *m) {
    sem_wait(&m->lock);
}

void ns_mutex_release(ns_mutex_t *m) {
    sem_post(&m->lock);

    sem_post(&m->barrier);
    sem_wait(&m->barrier);

    sem_wait(&m->mutex);
    for (int i = 0; i < m->num_threads; i++) {
        sem_post(&m->barrier);
        //确认所有线程都执行过临界区后再继续执行
    }
    sem_post(&m->mutex);
}


void *worker(void *arg) {
    return NULL;
}

int main(int argc, char *argv[]) {
    printf("parent: begin\n");
    printf("parent: end\n");
    return 0;
}

```
